# AI英语工作助手 - 前端技术实现方案

## 技术架构概览

### 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   浏览器插件     │    │   桌面应用       │    │   移动端应用     │
│  (Chrome Ext)   │    │  (Electron)     │    │  (React Native) │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   API Gateway   │
                    │   (FastAPI)     │
                    └─────────────────┘
```

## 1. 浏览器插件开发

### 1.1 技术栈
- **框架**: Manifest V3 (Chrome Extension)
- **前端**: React 18 + TypeScript
- **状态管理**: Zustand
- **UI组件**: Ant Design + Tailwind CSS
- **构建工具**: Vite + CRXJS
- **API通信**: Axios

### 1.2 项目结构
```
browser-extension/
├── manifest.json
├── src/
│   ├── background/
│   │   ├── background.ts          # Service Worker
│   │   └── api.ts                 # API调用封装
│   ├── content/
│   │   ├── content.ts             # 内容脚本
│   │   ├── translator.ts          # 翻译功能
│   │   └── selector.ts            # 文本选择
│   ├── popup/
│   │   ├── Popup.tsx              # 弹窗主界面
│   │   ├── components/
│   │   │   ├── TranslationCard.tsx
│   │   │   ├── VocabularyList.tsx
│   │   │   └── SettingsPanel.tsx
│   │   └── hooks/
│   │       ├── useTranslation.ts
│   │       └── useVocabulary.ts
│   ├── options/
│   │   ├── Options.tsx            # 设置页面
│   │   └── components/
│   ├── shared/
│   │   ├── types/
│   │   ├── utils/
│   │   ├── constants/
│   │   └── stores/
│   │       ├── authStore.ts
│   │       ├── translationStore.ts
│   │       └── vocabularyStore.ts
│   └── assets/
├── public/
│   ├── icons/
│   └── _locales/
├── package.json
├── vite.config.ts
└── tailwind.config.js
```

### 1.3 核心功能实现

#### 1.3.1 Manifest配置
```json
{
  "manifest_version": 3,
  "name": "AI英语工作助手",
  "version": "1.0.0",
  "description": "智能英语翻译与学习助手",
  "permissions": [
    "activeTab",
    "storage",
    "contextMenus",
    "notifications",
    "scripting"
  ],
  "host_permissions": [
    "https://api.englishassistant.com/*"
  ],
  "background": {
    "service_worker": "src/background/background.ts",
    "type": "module"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["src/content/content.ts"],
      "css": ["src/content/content.css"]
    }
  ],
  "action": {
    "default_popup": "src/popup/popup.html",
    "default_title": "AI英语助手"
  },
  "options_page": "src/options/options.html",
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}
```

#### 1.3.2 悬停翻译实现
```typescript
// src/content/translator.ts
class HoverTranslator {
  private tooltip: HTMLElement | null = null;
  private debounceTimer: number | null = null;
  
  constructor() {
    this.init();
  }
  
  private init() {
    document.addEventListener('mouseup', this.handleTextSelection.bind(this));
    document.addEventListener('mouseover', this.handleMouseOver.bind(this));
    document.addEventListener('keydown', this.handleKeyDown.bind(this));
  }
  
  private handleTextSelection(event: MouseEvent) {
    const selection = window.getSelection();
    const selectedText = selection?.toString().trim();
    
    if (selectedText && selectedText.length > 0) {
      this.showTranslationTooltip(selectedText, event.clientX, event.clientY);
    }
  }
  
  private handleMouseOver(event: MouseEvent) {
    const target = event.target as HTMLElement;
    
    // 检查是否启用悬停翻译
    if (!this.isHoverTranslationEnabled()) return;
    
    // 获取悬停的单词
    const word = this.getWordAtPosition(target, event.clientX, event.clientY);
    
    if (word && this.isEnglishWord(word)) {
      this.debounceTranslation(word, event.clientX, event.clientY);
    }
  }
  
  private debounceTranslation(word: string, x: number, y: number) {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    
    this.debounceTimer = window.setTimeout(() => {
      this.translateWord(word, x, y);
    }, 500); // 500ms延迟
  }
  
  private async translateWord(word: string, x: number, y: number) {
    try {
      const translation = await this.requestTranslation(word);
      this.showTooltip(word, translation, x, y);
    } catch (error) {
      console.error('Translation failed:', error);
    }
  }
  
  private async requestTranslation(text: string) {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({
        type: 'TRANSLATE',
        payload: { text }
      }, (response) => {
        resolve(response.data);
      });
    });
  }
  
  private showTooltip(word: string, translation: any, x: number, y: number) {
    this.hideTooltip();
    
    this.tooltip = document.createElement('div');
    this.tooltip.className = 'ai-english-tooltip';
    this.tooltip.innerHTML = `
      <div class="tooltip-content">
        <div class="word">${word}</div>
        <div class="translation">${translation.translated_text}</div>
        <div class="pronunciation">${translation.pronunciation?.ipa || ''}</div>
        <button class="save-btn" data-word="${word}">保存</button>
      </div>
    `;
    
    // 设置位置
    this.tooltip.style.left = `${x}px`;
    this.tooltip.style.top = `${y - 60}px`;
    
    document.body.appendChild(this.tooltip);
    
    // 添加保存按钮事件
    const saveBtn = this.tooltip.querySelector('.save-btn');
    saveBtn?.addEventListener('click', () => {
      this.saveVocabulary(word, translation);
    });
    
    // 3秒后自动隐藏
    setTimeout(() => this.hideTooltip(), 3000);
  }
  
  private hideTooltip() {
    if (this.tooltip) {
      this.tooltip.remove();
      this.tooltip = null;
    }
  }
  
  private async saveVocabulary(word: string, translation: any) {
    chrome.runtime.sendMessage({
      type: 'SAVE_VOCABULARY',
      payload: {
        word,
        translation: translation.translated_text,
        context: translation.context,
        source_url: window.location.href
      }
    });
    
    this.showNotification('词汇已保存');
  }
}

// 初始化
new HoverTranslator();
```

#### 1.3.3 Agent状态监控组件
```typescript
// src/components/AgentStatusMonitor.tsx
import React, { useState, useEffect } from 'react';
import { Progress, Card, Tag, Timeline, Spin } from 'antd';
import { useAgentStore } from '../stores/agentStore';

interface AgentSession {
  session_id: string;
  status: 'created' | 'running' | 'completed' | 'failed' | 'cancelled';
  current_step: string;
  progress_percentage: number;
  workflow_steps: string[];
  processing_time_ms?: number;
}

export const AgentStatusMonitor: React.FC = () => {
  const { activeSessions, getSessionStatus } = useAgentStore();
  const [selectedSession, setSelectedSession] = useState<string | null>(null);
  
  useEffect(() => {
    // 定期更新会话状态
    const interval = setInterval(() => {
      activeSessions.forEach(session => {
        if (session.status === 'running') {
          getSessionStatus(session.session_id);
        }
      });
    }, 1000);
    
    return () => clearInterval(interval);
  }, [activeSessions, getSessionStatus]);
  
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'running': return 'processing';
      case 'completed': return 'success';
      case 'failed': return 'error';
      case 'cancelled': return 'warning';
      default: return 'default';
    }
  };
  
  return (
    <div className="agent-status-monitor">
      <Card title="Agent工作流状态" size="small">
        {activeSessions.map(session => (
          <Card.Grid 
            key={session.session_id}
            style={{ width: '100%', padding: '12px' }}
            hoverable
            onClick={() => setSelectedSession(session.session_id)}
          >
            <div className="session-header">
              <Tag color={getStatusColor(session.status)}>
                {session.status.toUpperCase()}
              </Tag>
              <span className="session-id">
                {session.session_id.slice(0, 8)}...
              </span>
            </div>
            
            <div className="session-progress">
              <Progress 
                percent={session.progress_percentage}
                size="small"
                status={session.status === 'failed' ? 'exception' : 'active'}
              />
              <div className="current-step">
                当前步骤: {session.current_step || '准备中'}
              </div>
            </div>
            
            {session.processing_time_ms && (
              <div className="processing-time">
                处理时间: {session.processing_time_ms}ms
              </div>
            )}
          </Card.Grid>
        ))}
        
        {activeSessions.length === 0 && (
          <div className="no-sessions">
            <Spin size="small" /> 暂无活跃的Agent会话
          </div>
        )}
      </Card>
      
      {selectedSession && (
        <AgentWorkflowDetail sessionId={selectedSession} />
      )}
    </div>
  );
};
```

#### 1.3.4 Agent工作流详情组件
```typescript
// src/components/AgentWorkflowDetail.tsx
import React, { useState, useEffect } from 'react';
import { Modal, Timeline, Descriptions, Tag, Alert } from 'antd';
import { CheckCircleOutlined, LoadingOutlined, CloseCircleOutlined } from '@ant-design/icons';
import { useAgentStore } from '../stores/agentStore';

interface Props {
  sessionId: string;
}

export const AgentWorkflowDetail: React.FC<Props> = ({ sessionId }) => {
  const { getWorkflowSteps, sessions } = useAgentStore();
  const [steps, setSteps] = useState([]);
  const [visible, setVisible] = useState(true);
  
  const session = sessions.find(s => s.session_id === sessionId);
  
  useEffect(() => {
    if (sessionId) {
      getWorkflowSteps(sessionId).then(setSteps);
    }
  }, [sessionId, getWorkflowSteps]);
  
  const getStepIcon = (status: string) => {
    switch (status) {
      case 'completed': return <CheckCircleOutlined style={{ color: '#52c41a' }} />;
      case 'running': return <LoadingOutlined style={{ color: '#1890ff' }} />;
      case 'failed': return <CloseCircleOutlined style={{ color: '#ff4d4f' }} />;
      default: return null;
    }
  };
  
  return (
    <Modal
      title={`Agent工作流详情 - ${sessionId.slice(0, 8)}`}
      open={visible}
      onCancel={() => setVisible(false)}
      footer={null}
      width={800}
    >
      {session && (
        <Descriptions column={2} size="small" style={{ marginBottom: 16 }}>
          <Descriptions.Item label="会话类型">{session.session_type}</Descriptions.Item>
          <Descriptions.Item label="工作流名称">{session.workflow_name}</Descriptions.Item>
          <Descriptions.Item label="状态">
            <Tag color={getStatusColor(session.status)}>{session.status}</Tag>
          </Descriptions.Item>
          <Descriptions.Item label="进度">{session.progress_percentage}%</Descriptions.Item>
        </Descriptions>
      )}
      
      <Timeline>
        {steps.map((step, index) => (
          <Timeline.Item
            key={step.step_id}
            dot={getStepIcon(step.status)}
            color={step.status === 'completed' ? 'green' : 
                   step.status === 'running' ? 'blue' : 
                   step.status === 'failed' ? 'red' : 'gray'}
          >
            <div className="step-content">
              <div className="step-header">
                <strong>{step.step_name}</strong>
                <Tag size="small">{step.status}</Tag>
              </div>
              
              {step.execution_time_ms && (
                <div className="step-timing">
                  执行时间: {step.execution_time_ms}ms
                </div>
              )}
              
              {step.error_message && (
                <Alert
                  message={step.error_message}
                  type="error"
                  size="small"
                  style={{ marginTop: 8 }}
                />
              )}
            </div>
          </Timeline.Item>
        ))}
      </Timeline>
    </Modal>
  );
};
```

#### 1.3.5 截图翻译实现
```typescript
// src/content/screenshot.ts
class ScreenshotTranslator {
  private isSelecting = false;
  private startX = 0;
  private startY = 0;
  private selectionBox: HTMLElement | null = null;
  
  constructor() {
    this.init();
  }
  
  private init() {
    // 监听快捷键
    document.addEventListener('keydown', (event) => {
      if (event.ctrlKey && event.shiftKey && event.key === 'S') {
        event.preventDefault();
        this.startScreenshotSelection();
      }
    });
  }
```

#### 1.3.6 Agent状态管理Store
```typescript
// src/stores/agentStore.ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { apiClient } from '../utils/apiClient';

interface AgentSession {
  session_id: string;
  user_id: string;
  session_type: string;
  workflow_name: string;
  status: 'created' | 'running' | 'completed' | 'failed' | 'cancelled';
  current_step?: string;
  progress_percentage: number;
  input_data: any;
  output_data?: any;
  processing_time_ms?: number;
  quality_score?: number;
  confidence_score?: number;
  error_log?: any[];
  created_at: string;
  updated_at: string;
}

interface WorkflowStep {
  step_id: string;
  session_id: string;
  step_name: string;
  step_order: number;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';
  input_data?: any;
  output_data?: any;
  execution_time_ms?: number;
  error_message?: string;
  started_at?: string;
  completed_at?: string;
}

interface AgentState {
  // 状态
  sessions: AgentSession[];
  activeSessions: AgentSession[];
  currentSession: AgentSession | null;
  workflowSteps: { [sessionId: string]: WorkflowStep[] };
  isLoading: boolean;
  error: string | null;
  
  // 动作
  createTranslationSession: (text: string, options: any) => Promise<string>;
  createBatchSession: (texts: any[], options: any) => Promise<string>;
  createOCRSession: (imageFile: File, options: any) => Promise<string>;
  getSessionStatus: (sessionId: string) => Promise<AgentSession | null>;
  getWorkflowSteps: (sessionId: string) => Promise<WorkflowStep[]>;
  cancelSession: (sessionId: string) => Promise<boolean>;
  clearCompletedSessions: () => void;
  setCurrentSession: (session: AgentSession | null) => void;
  updateSessionStatus: (sessionId: string, updates: Partial<AgentSession>) => void;
}

export const useAgentStore = create<AgentState>()(devtools(
  (set, get) => ({
    // 初始状态
    sessions: [],
    activeSessions: [],
    currentSession: null,
    workflowSteps: {},
    isLoading: false,
    error: null,
    
    // 创建翻译会话
    createTranslationSession: async (text: string, options: any) => {
      set({ isLoading: true, error: null });
      
      try {
        const response = await apiClient.post('/agent/translate', {
          text,
          ...options,
          session_id: `trans_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        });
        
        const sessionId = response.data.session_id;
        const session: AgentSession = {
          session_id: sessionId,
          user_id: options.user_id,
          session_type: 'translation',
          workflow_name: 'EnterpriseAgentSystem',
          status: 'running',
          progress_percentage: 0,
          input_data: { text, ...options },
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };
        
        set(state => ({
          sessions: [...state.sessions, session],
          activeSessions: [...state.activeSessions, session],
          currentSession: session,
          isLoading: false
        }));
        
        // 开始轮询状态
        get().pollSessionStatus(sessionId);
        
        return sessionId;
      } catch (error) {
        set({ error: error.message, isLoading: false });
        throw error;
      }
    },
    
    // 创建批量翻译会话
    createBatchSession: async (texts: any[], options: any) => {
      set({ isLoading: true, error: null });
      
      try {
        const response = await apiClient.post('/agent/translate/batch', {
          texts,
          ...options,
          session_id: `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        });
        
        const sessionId = response.data.session_id;
        const session: AgentSession = {
          session_id: sessionId,
          user_id: options.user_id,
          session_type: 'batch_translation',
          workflow_name: 'BatchProcessor',
          status: 'running',
          progress_percentage: 0,
          input_data: { texts, ...options },
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };
        
        set(state => ({
          sessions: [...state.sessions, session],
          activeSessions: [...state.activeSessions, session],
          isLoading: false
        }));
        
        get().pollSessionStatus(sessionId);
        
        return sessionId;
      } catch (error) {
        set({ error: error.message, isLoading: false });
        throw error;
      }
    },
    
    // 创建OCR翻译会话
    createOCRSession: async (imageFile: File, options: any) => {
      set({ isLoading: true, error: null });
      
      try {
        const formData = new FormData();
        formData.append('image', imageFile);
        Object.keys(options).forEach(key => {
          formData.append(key, options[key]);
        });
        formData.append('session_id', `ocr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`);
        
        const response = await apiClient.post('/agent/translate/ocr', formData, {
          headers: { 'Content-Type': 'multipart/form-data' }
        });
        
        const sessionId = response.data.session_id;
        const session: AgentSession = {
          session_id: sessionId,
          user_id: options.user_id,
          session_type: 'ocr_translation',
          workflow_name: 'OCRProcessor',
          status: 'running',
          progress_percentage: 0,
          input_data: { image_name: imageFile.name, ...options },
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };
        
        set(state => ({
          sessions: [...state.sessions, session],
          activeSessions: [...state.activeSessions, session],
          isLoading: false
        }));
        
        get().pollSessionStatus(sessionId);
        
        return sessionId;
      } catch (error) {
        set({ error: error.message, isLoading: false });
        throw error;
      }
    },
    
    // 获取会话状态
    getSessionStatus: async (sessionId: string) => {
      try {
        const response = await apiClient.get(`/agent/workflow/${sessionId}/status`);
        const sessionData = response.data;
        
        set(state => ({
          sessions: state.sessions.map(s => 
            s.session_id === sessionId ? { ...s, ...sessionData } : s
          ),
          activeSessions: state.activeSessions.map(s => 
            s.session_id === sessionId ? { ...s, ...sessionData } : s
          )
        }));
        
        return sessionData;
      } catch (error) {
        console.error('Failed to get session status:', error);
        return null;
      }
    },
    
    // 获取工作流步骤
    getWorkflowSteps: async (sessionId: string) => {
      try {
        const response = await apiClient.get(`/agent/workflow/${sessionId}/steps`);
        const steps = response.data;
        
        set(state => ({
          workflowSteps: {
            ...state.workflowSteps,
            [sessionId]: steps
          }
        }));
        
        return steps;
      } catch (error) {
        console.error('Failed to get workflow steps:', error);
        return [];
      }
    },
    
    // 取消会话
    cancelSession: async (sessionId: string) => {
      try {
        await apiClient.post(`/agent/workflow/${sessionId}/cancel`);
        
        set(state => ({
          sessions: state.sessions.map(s => 
            s.session_id === sessionId ? { ...s, status: 'cancelled' } : s
          ),
          activeSessions: state.activeSessions.filter(s => s.session_id !== sessionId)
        }));
        
        return true;
      } catch (error) {
        console.error('Failed to cancel session:', error);
        return false;
      }
    },
    
    // 清理已完成的会话
    clearCompletedSessions: () => {
      set(state => ({
        activeSessions: state.activeSessions.filter(s => 
          !['completed', 'failed', 'cancelled'].includes(s.status)
        )
      }));
    },
    
    // 设置当前会话
    setCurrentSession: (session: AgentSession | null) => {
      set({ currentSession: session });
    },
    
    // 更新会话状态
    updateSessionStatus: (sessionId: string, updates: Partial<AgentSession>) => {
      set(state => ({
        sessions: state.sessions.map(s => 
          s.session_id === sessionId ? { ...s, ...updates } : s
        ),
        activeSessions: state.activeSessions.map(s => 
          s.session_id === sessionId ? { ...s, ...updates } : s
        )
      }));
    },
    
    // 轮询会话状态（私有方法）
    pollSessionStatus: (sessionId: string) => {
      const poll = async () => {
        const session = await get().getSessionStatus(sessionId);
        
        if (session && ['completed', 'failed', 'cancelled'].includes(session.status)) {
          return; // 停止轮询
        }
        
        setTimeout(poll, 1000); // 1秒后继续轮询
      };
      
      poll();
    }
  }),
  {
    name: 'agent-store',
    partialize: (state) => ({
      sessions: state.sessions.filter(s => 
        Date.now() - new Date(s.created_at).getTime() < 24 * 60 * 60 * 1000 // 保留24小时内的会话
      )
    })
  }
));
  
  private startScreenshotSelection() {
    this.isSelecting = true;
    document.body.style.cursor = 'crosshair';
    
    // 创建遮罩层
    const overlay = document.createElement('div');
    overlay.className = 'screenshot-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.3);
      z-index: 10000;
      cursor: crosshair;
    `;
    
    document.body.appendChild(overlay);
    
    overlay.addEventListener('mousedown', this.handleMouseDown.bind(this));
    overlay.addEventListener('mousemove', this.handleMouseMove.bind(this));
    overlay.addEventListener('mouseup', this.handleMouseUp.bind(this));
  }
  
  private handleMouseDown(event: MouseEvent) {
    this.startX = event.clientX;
    this.startY = event.clientY;
    
    this.selectionBox = document.createElement('div');
    this.selectionBox.className = 'selection-box';
    this.selectionBox.style.cssText = `
      position: fixed;
      border: 2px dashed #007bff;
      background: rgba(0, 123, 255, 0.1);
      z-index: 10001;
    `;
    
    document.body.appendChild(this.selectionBox);
  }
  
  private handleMouseMove(event: MouseEvent) {
    if (!this.selectionBox) return;
    
    const width = Math.abs(event.clientX - this.startX);
    const height = Math.abs(event.clientY - this.startY);
    const left = Math.min(event.clientX, this.startX);
    const top = Math.min(event.clientY, this.startY);
    
    this.selectionBox.style.left = `${left}px`;
    this.selectionBox.style.top = `${top}px`;
    this.selectionBox.style.width = `${width}px`;
    this.selectionBox.style.height = `${height}px`;
  }
  
  private async handleMouseUp(event: MouseEvent) {
    if (!this.selectionBox) return;
    
    const rect = this.selectionBox.getBoundingClientRect();
    
    // 清理UI
    this.cleanup();
    
    // 截图并翻译
    try {
      const canvas = await this.captureArea(rect);
      const blob = await this.canvasToBlob(canvas);
      const translation = await this.translateImage(blob);
      
      this.showTranslationResult(translation, rect);
    } catch (error) {
      console.error('Screenshot translation failed:', error);
      this.showError('截图翻译失败');
    }
  }
  
  private async captureArea(rect: DOMRect): Promise<HTMLCanvasElement> {
    // 使用 Screen Capture API
    const stream = await navigator.mediaDevices.getDisplayMedia({
      video: { mediaSource: 'screen' }
    });
    
    const video = document.createElement('video');
    video.srcObject = stream;
    video.play();
    
    return new Promise((resolve) => {
      video.addEventListener('loadedmetadata', () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d')!;
        
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        ctx.drawImage(
          video,
          rect.left, rect.top, rect.width, rect.height,
          0, 0, rect.width, rect.height
        );
        
        stream.getTracks().forEach(track => track.stop());
        resolve(canvas);
      });
    });
  }
  
  private async translateImage(blob: Blob) {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({
        type: 'TRANSLATE_IMAGE',
        payload: { image: blob }
      }, (response) => {
        resolve(response.data);
      });
    });
  }
  
  private cleanup() {
    document.body.style.cursor = '';
    document.querySelector('.screenshot-overlay')?.remove();
    this.selectionBox?.remove();
    this.selectionBox = null;
    this.isSelecting = false;
  }
}

new ScreenshotTranslator();
```

#### 1.3.4 状态管理
```typescript
// src/shared/stores/translationStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface TranslationState {
  history: Translation[];
  currentTranslation: Translation | null;
  isLoading: boolean;
  settings: TranslationSettings;
  
  // Actions
  translate: (text: string, options?: TranslateOptions) => Promise<Translation>;
  saveToHistory: (translation: Translation) => void;
  clearHistory: () => void;
  updateSettings: (settings: Partial<TranslationSettings>) => void;
}

interface Translation {
  id: string;
  originalText: string;
  translatedText: string;
  sourceLang: string;
  targetLang: string;
  context?: string;
  sourceUrl?: string;
  timestamp: number;
  confidence: number;
}

interface TranslationSettings {
  autoTranslate: boolean;
  hoverDelay: number;
  showPronunciation: boolean;
  saveToHistory: boolean;
  defaultSourceLang: string;
  defaultTargetLang: string;
}

export const useTranslationStore = create<TranslationState>()(n  persist(
    (set, get) => ({
      history: [],
      currentTranslation: null,
      isLoading: false,
      settings: {
        autoTranslate: true,
        hoverDelay: 500,
        showPronunciation: true,
        saveToHistory: true,
        defaultSourceLang: 'en',
        defaultTargetLang: 'zh'
      },
      
      translate: async (text: string, options = {}) => {
        set({ isLoading: true });
        
        try {
          const response = await chrome.runtime.sendMessage({
            type: 'TRANSLATE',
            payload: {
              text,
              source_lang: options.sourceLang || get().settings.defaultSourceLang,
              target_lang: options.targetLang || get().settings.defaultTargetLang,
              context: options.context,
              source_url: window.location.href
            }
          });
          
          const translation: Translation = {
            id: Date.now().toString(),
            originalText: text,
            translatedText: response.data.translated_text,
            sourceLang: response.data.source_lang,
            targetLang: response.data.target_lang,
            context: options.context,
            sourceUrl: window.location.href,
            timestamp: Date.now(),
            confidence: response.data.confidence
          };
          
          set({ currentTranslation: translation, isLoading: false });
          
          if (get().settings.saveToHistory) {
            get().saveToHistory(translation);
          }
          
          return translation;
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },
      
      saveToHistory: (translation: Translation) => {
        set(state => ({
          history: [translation, ...state.history.slice(0, 99)] // 保留最近100条
        }));
      },
      
      clearHistory: () => {
        set({ history: [] });
      },
      
      updateSettings: (newSettings: Partial<TranslationSettings>) => {
        set(state => ({
          settings: { ...state.settings, ...newSettings }
        }));
      }
    }),
    {
      name: 'translation-store',
      partialize: (state) => ({
        history: state.history,
        settings: state.settings
      })
    }
  )
);
```

### 1.4 UI组件实现

#### 1.4.1 翻译卡片组件
```tsx
// src/popup/components/TranslationCard.tsx
import React from 'react';
import { Card, Button, Typography, Space, Tag } from 'antd';
import { SoundOutlined, BookOutlined, CopyOutlined } from '@ant-design/icons';

const { Text, Paragraph } = Typography;

interface TranslationCardProps {
  translation: Translation;
  onSave?: () => void;
  onPlayAudio?: () => void;
}

export const TranslationCard: React.FC<TranslationCardProps> = ({
  translation,
  onSave,
  onPlayAudio
}) => {
  const handleCopy = () => {
    navigator.clipboard.writeText(translation.translatedText);
  };
  
  return (
    <Card 
      size="small" 
      className="translation-card"
      actions={[
        <Button 
          type="text" 
          icon={<SoundOutlined />} 
          onClick={onPlayAudio}
          size="small"
        />,
        <Button 
          type="text" 
          icon={<CopyOutlined />} 
          onClick={handleCopy}
          size="small"
        />,
        <Button 
          type="text" 
          icon={<BookOutlined />} 
          onClick={onSave}
          size="small"
        />
      ]}
    >
      <Space direction="vertical" size="small" style={{ width: '100%' }}>
        <div>
          <Text strong>{translation.originalText}</Text>
          <Tag size="small" style={{ marginLeft: 8 }}>
            {translation.sourceLang} → {translation.targetLang}
          </Tag>
        </div>
        
        <Paragraph className="translation-text">
          {translation.translatedText}
        </Paragraph>
        
        {translation.pronunciation && (
          <Text type="secondary" className="pronunciation">
            {translation.pronunciation.ipa}
          </Text>
        )}
        
        {translation.context && (
          <Text type="secondary" className="context">
            上下文: {translation.context}
          </Text>
        )}
        
        <div className="confidence-bar">
          <Text type="secondary">置信度: </Text>
          <div className="confidence-progress">
            <div 
              className="confidence-fill"
              style={{ width: `${translation.confidence * 100}%` }}
            />
          </div>
          <Text type="secondary">{Math.round(translation.confidence * 100)}%</Text>
        </div>
      </Space>
    </Card>
  );
};
```

#### 1.4.2 词汇列表组件
```tsx
// src/popup/components/VocabularyList.tsx
import React, { useState, useEffect } from 'react';
import { List, Card, Tag, Button, Input, Select, Space } from 'antd';
import { SearchOutlined, FilterOutlined } from '@ant-design/icons';
import { useVocabularyStore } from '../../shared/stores/vocabularyStore';

const { Search } = Input;
const { Option } = Select;

export const VocabularyList: React.FC = () => {
  const {
    vocabularies,
    isLoading,
    filters,
    fetchVocabularies,
    updateFilters,
    deleteVocabulary
  } = useVocabularyStore();
  
  const [searchText, setSearchText] = useState('');
  
  useEffect(() => {
    fetchVocabularies();
  }, []);
  
  const handleSearch = (value: string) => {
    setSearchText(value);
    updateFilters({ search: value });
  };
  
  const handleFilterChange = (key: string, value: any) => {
    updateFilters({ [key]: value });
  };
  
  const filteredVocabularies = vocabularies.filter(vocab => {
    if (searchText && !vocab.word.toLowerCase().includes(searchText.toLowerCase())) {
      return false;
    }
    if (filters.difficulty && vocab.difficulty !== filters.difficulty) {
      return false;
    }
    if (filters.mastery_level && vocab.mastery_level !== filters.mastery_level) {
      return false;
    }
    return true;
  });
  
  return (
    <div className="vocabulary-list">
      <Space direction="vertical" size="middle" style={{ width: '100%' }}>
        <div className="filters">
          <Search
            placeholder="搜索单词..."
            allowClear
            onSearch={handleSearch}
            style={{ marginBottom: 8 }}
          />
          
          <Space>
            <Select
              placeholder="难度"
              allowClear
              style={{ width: 100 }}
              onChange={(value) => handleFilterChange('difficulty', value)}
            >
              <Option value={1}>简单</Option>
              <Option value={2}>一般</Option>
              <Option value={3}>困难</Option>
              <Option value={4}>很难</Option>
            </Select>
            
            <Select
              placeholder="掌握程度"
              allowClear
              style={{ width: 120 }}
              onChange={(value) => handleFilterChange('mastery_level', value)}
            >
              <Option value={0}>未掌握</Option>
              <Option value={1}>初步</Option>
              <Option value={2}>熟悉</Option>
              <Option value={3}>掌握</Option>
              <Option value={4}>精通</Option>
            </Select>
          </Space>
        </div>
        
        <List
          loading={isLoading}
          dataSource={filteredVocabularies}
          renderItem={(vocab) => (
            <List.Item>
              <Card size="small" style={{ width: '100%' }}>
                <div className="vocab-header">
                  <span className="word">{vocab.word}</span>
                  <Space>
                    <Tag color={getDifficultyColor(vocab.difficulty)}>
                      难度{vocab.difficulty}
                    </Tag>
                    <Tag color={getMasteryColor(vocab.mastery_level)}>
                      {getMasteryText(vocab.mastery_level)}
                    </Tag>
                  </Space>
                </div>
                
                <div className="translation">{vocab.translation}</div>
                
                {vocab.context && (
                  <div className="context">
                    <Text type="secondary">{vocab.context}</Text>
                  </div>
                )}
                
                {vocab.tags && vocab.tags.length > 0 && (
                  <div className="tags">
                    {vocab.tags.map(tag => (
                      <Tag key={tag} size="small">{tag}</Tag>
                    ))}
                  </div>
                )}
                
                <div className="vocab-footer">
                  <Text type="secondary">
                    下次复习: {formatDate(vocab.next_review_date)}
                  </Text>
                  <Button 
                    type="link" 
                    size="small" 
                    danger
                    onClick={() => deleteVocabulary(vocab.vocabulary_id)}
                  >
                    删除
                  </Button>
                </div>
              </Card>
            </List.Item>
          )}
        />
      </Space>
    </div>
  );
};

// 辅助函数
const getDifficultyColor = (difficulty: number) => {
  const colors = ['green', 'blue', 'orange', 'red'];
  return colors[difficulty - 1] || 'default';
};

const getMasteryColor = (level: number) => {
  const colors = ['red', 'orange', 'blue', 'green', 'purple'];
  return colors[level] || 'default';
};

const getMasteryText = (level: number) => {
  const texts = ['未掌握', '初步', '熟悉', '掌握', '精通'];
  return texts[level] || '未知';
};

const formatDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString('zh-CN');
};
```

## 2. 桌面应用开发 (Electron)

### 2.1 技术栈
- **框架**: Electron 28+
- **前端**: React 18 + TypeScript
- **状态管理**: Redux Toolkit
- **UI组件**: Ant Design + Styled Components
- **构建工具**: Electron Builder
- **系统集成**: Python Backend Integration

### 2.2 项目结构
```
desktop-app/
├── electron/
│   ├── main.ts                    # 主进程
│   ├── preload.ts                 # 预加载脚本
│   ├── services/
│   │   ├── globalShortcut.ts      # 全局快捷键
│   │   ├── systemTray.ts          # 系统托盘
│   │   ├── autoUpdater.ts         # 自动更新
│   │   └── notification.ts        # 系统通知
│   └── utils/
├── src/
│   ├── renderer/
│   │   ├── App.tsx
│   │   ├── pages/
│   │   │   ├── Dashboard.tsx
│   │   │   ├── Vocabulary.tsx
│   │   │   ├── Review.tsx
│   │   │   └── Settings.tsx
│   │   ├── components/
│   │   └── hooks/
│   ├── shared/
│   └── types/
├── package.json
├── electron-builder.json
└── tsconfig.json
```

### 2.3 核心功能实现

#### 2.3.1 全局快捷键
```typescript
// electron/services/globalShortcut.ts
import { globalShortcut, BrowserWindow } from 'electron';

export class GlobalShortcutService {
  private mainWindow: BrowserWindow;
  
  constructor(mainWindow: BrowserWindow) {
    this.mainWindow = mainWindow;
    this.registerShortcuts();
  }
  
  private registerShortcuts() {
    // 快速翻译
    globalShortcut.register('CommandOrControl+Shift+T', () => {
      this.showQuickTranslate();
    });
    
    // 截图翻译
    globalShortcut.register('CommandOrControl+Shift+S', () => {
      this.startScreenshotTranslation();
    });
    
    // 显示/隐藏主窗口
    globalShortcut.register('CommandOrControl+Shift+E', () => {
      this.toggleMainWindow();
    });
    
    // 快速添加词汇
    globalShortcut.register('CommandOrControl+Shift+A', () => {
      this.showQuickAdd();
    });
  }
  
  private showQuickTranslate() {
    // 创建快速翻译窗口
    const quickWindow = new BrowserWindow({
      width: 400,
      height: 300,
      frame: false,
      alwaysOnTop: true,
      skipTaskbar: true,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js')
      }
    });
    
    quickWindow.loadFile('quick-translate.html');
    
    // 获取鼠标位置并显示窗口
    const { screen } = require('electron');
    const cursor = screen.getCursorScreenPoint();
    quickWindow.setPosition(cursor.x - 200, cursor.y - 150);
    
    // 失去焦点时关闭
    quickWindow.on('blur', () => {
      quickWindow.close();
    });
  }
  
  private async startScreenshotTranslation() {
    const { desktopCapturer } = require('electron');
    
    try {
      const sources = await desktopCapturer.getSources({
        types: ['screen'],
        thumbnailSize: { width: 1920, height: 1080 }
      });
      
      // 创建截图选择窗口
      const screenshotWindow = new BrowserWindow({
        fullscreen: true,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true,
          preload: path.join(__dirname, 'preload.js')
        }
      });
      
      screenshotWindow.loadFile('screenshot.html');
      
      // 传递屏幕截图数据
      screenshotWindow.webContents.once('did-finish-load', () => {
        screenshotWindow.webContents.send('screenshot-data', {
          screenshot: sources[0].thumbnail.toDataURL()
        });
      });
      
    } catch (error) {
      console.error('Screenshot failed:', error);
    }
  }
  
  private toggleMainWindow() {
    if (this.mainWindow.isVisible()) {
      this.mainWindow.hide();
    } else {
      this.mainWindow.show();
      this.mainWindow.focus();
    }
  }
  
  private showQuickAdd() {
    // 获取剪贴板内容
    const { clipboard } = require('electron');
    const clipboardText = clipboard.readText();
    
    // 如果剪贴板有英文文本，直接翻译并显示保存对话框
    if (clipboardText && /^[a-zA-Z\s]+$/.test(clipboardText.trim())) {
      this.mainWindow.webContents.send('quick-add-vocabulary', {
        text: clipboardText.trim()
      });
      this.mainWindow.show();
      this.mainWindow.focus();
    }
  }
  
  public unregisterAll() {
    globalShortcut.unregisterAll();
  }
}
```

#### 2.3.2 系统托盘
```typescript
// electron/services/systemTray.ts
import { Tray, Menu, BrowserWindow, nativeImage } from 'electron';
import path from 'path';

export class SystemTrayService {
  private tray: Tray;
  private mainWindow: BrowserWindow;
  
  constructor(mainWindow: BrowserWindow) {
    this.mainWindow = mainWindow;
    this.createTray();
  }
  
  private createTray() {
    const iconPath = path.join(__dirname, '../assets/tray-icon.png');
    const trayIcon = nativeImage.createFromPath(iconPath);
    
    this.tray = new Tray(trayIcon.resize({ width: 16, height: 16 }));
    this.tray.setToolTip('AI英语工作助手');
    
    this.updateContextMenu();
    
    // 点击托盘图标显示/隐藏窗口
    this.tray.on('click', () => {
      if (this.mainWindow.isVisible()) {
        this.mainWindow.hide();
      } else {
        this.mainWindow.show();
        this.mainWindow.focus();
      }
    });
  }
  
  private updateContextMenu() {
    const contextMenu = Menu.buildFromTemplate([
      {
        label: '快速翻译',
        accelerator: 'CommandOrControl+Shift+T',
        click: () => {
          // 触发快速翻译
          this.mainWindow.webContents.send('show-quick-translate');
        }
      },
      {
        label: '截图翻译',
        accelerator: 'CommandOrControl+Shift+S',
        click: () => {
          // 触发截图翻译
          this.mainWindow.webContents.send('start-screenshot');
        }
      },
      { type: 'separator' },
      {
        label: '今日复习',
        click: () => {
          this.mainWindow.show();
          this.mainWindow.webContents.send('navigate-to', '/review');
        }
      },
      {
        label: '词汇本',
        click: () => {
          this.mainWindow.show();
          this.mainWindow.webContents.send('navigate-to', '/vocabulary');
        }
      },
      { type: 'separator' },
      {
        label: '设置',
        click: () => {
          this.mainWindow.show();
          this.mainWindow.webContents.send('navigate-to', '/settings');
        }
      },
      {
        label: '关于',
        click: () => {
          // 显示关于对话框
        }
      },
      { type: 'separator' },
      {
        label: '退出',
        accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
        click: () => {
          this.mainWindow.destroy();
        }
      }
    ]);
    
    this.tray.setContextMenu(contextMenu);
  }
  
  public updateBadge(count: number) {
    if (count > 0) {
      this.tray.setTitle(count.toString());
    } else {
      this.tray.setTitle('');
    }
  }
  
  public destroy() {
    if (this.tray) {
      this.tray.destroy();
    }
  }
}
```

#### 2.3.3 主进程配置
```typescript
// electron/main.ts
import { app, BrowserWindow, ipcMain } from 'electron';
import { GlobalShortcutService } from './services/globalShortcut';
import { SystemTrayService } from './services/systemTray';
import { AutoUpdaterService } from './services/autoUpdater';
import path from 'path';

class MainApplication {
  private mainWindow: BrowserWindow | null = null;
  private globalShortcut: GlobalShortcutService | null = null;
  private systemTray: SystemTrayService | null = null;
  private autoUpdater: AutoUpdaterService | null = null;
  
  constructor() {
    this.init();
  }
  
  private init() {
    app.whenReady().then(() => {
      this.createMainWindow();
      this.setupServices();
      this.setupIpcHandlers();
    });
    
    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });
    
    app.on('activate', () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        this.createMainWindow();
      }
    });
    
    app.on('before-quit', () => {
      this.cleanup();
    });
  }
  
  private createMainWindow() {
    this.mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      minWidth: 800,
      minHeight: 600,
      show: false,
      titleBarStyle: 'hiddenInset',
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js'),
        webSecurity: true
      }
    });
    
    // 加载应用
    if (process.env.NODE_ENV === 'development') {
      this.mainWindow.loadURL('http://localhost:3000');
      this.mainWindow.webContents.openDevTools();
    } else {
      this.mainWindow.loadFile(path.join(__dirname, '../dist/index.html'));
    }
    
    // 窗口事件
    this.mainWindow.once('ready-to-show', () => {
      this.mainWindow?.show();
    });
    
    this.mainWindow.on('close', (event) => {
      if (process.platform === 'darwin') {
        event.preventDefault();
        this.mainWindow?.hide();
      }
    });
  }
  
  private setupServices() {
    if (this.mainWindow) {
      this.globalShortcut = new GlobalShortcutService(this.mainWindow);
      this.systemTray = new SystemTrayService(this.mainWindow);
      this.autoUpdater = new AutoUpdaterService(this.mainWindow);
    }
  }
  
  private setupIpcHandlers() {
    // 翻译请求
    ipcMain.handle('translate', async (event, data) => {
      try {
        const response = await fetch('https://api.englishassistant.com/v1/translate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${await this.getAuthToken()}`
          },
          body: JSON.stringify(data)
        });
        
        return await response.json();
      } catch (error) {
        throw new Error(`Translation failed: ${error.message}`);
      }
    });
    
    // 保存词汇
    ipcMain.handle('save-vocabulary', async (event, data) => {
      try {
        const response = await fetch('https://api.englishassistant.com/v1/vocabulary', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${await this.getAuthToken()}`
          },
          body: JSON.stringify(data)
        });
        
        return await response.json();
      } catch (error) {
        throw new Error(`Save vocabulary failed: ${error.message}`);
      }
    });
    
    // 获取复习列表
    ipcMain.handle('get-review-items', async (event) => {
      try {
        const response = await fetch('https://api.englishassistant.com/v1/review/today', {
          headers: {
            'Authorization': `Bearer ${await this.getAuthToken()}`
          }
        });
        
        return await response.json();
      } catch (error) {
        throw new Error(`Get review items failed: ${error.message}`);
      }
    });
    
    // 系统通知
    ipcMain.handle('show-notification', (event, { title, body }) => {
      new Notification({ title, body }).show();
    });
    
    // 更新托盘徽章
    ipcMain.handle('update-tray-badge', (event, count) => {
      this.systemTray?.updateBadge(count);
    });
  }
  
  private async getAuthToken(): Promise<string> {
    // 从安全存储中获取认证token
    const { safeStorage } = require('electron');
    // 实现token获取逻辑
    return 'your-auth-token';
  }
  
  private cleanup() {
    this.globalShortcut?.unregisterAll();
    this.systemTray?.destroy();
  }
}

new MainApplication();
```

## 3. 移动端应用 (React Native)

### 3.1 技术栈
- **框架**: React Native 0.72+
- **导航**: React Navigation 6
- **状态管理**: Redux Toolkit + RTK Query
- **UI组件**: React Native Elements
- **本地存储**: AsyncStorage + SQLite
- **推送通知**: React Native Push Notification

### 3.2 核心功能

#### 3.2.1 相机翻译
```typescript
// src/screens/CameraTranslateScreen.tsx
import React, { useState, useRef } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { Camera, useCameraDevices } from 'react-native-vision-camera';
import { useTranslation } from '../hooks/useTranslation';

export const CameraTranslateScreen: React.FC = () => {
  const [isActive, setIsActive] = useState(true);
  const [capturedImage, setCapturedImage] = useState<string | null>(null);
  const camera = useRef<Camera>(null);
  const devices = useCameraDevices();
  const device = devices.back;
  
  const { translateImage, isLoading } = useTranslation();
  
  const handleCapture = async () => {
    if (camera.current) {
      try {
        const photo = await camera.current.takePhoto({
          quality: 0.8,
          enableAutoRedEyeReduction: true
        });
        
        setCapturedImage(photo.path);
        
        // 翻译图片
        const result = await translateImage(photo.path);
        
        // 显示翻译结果
        navigation.navigate('TranslationResult', { result });
        
      } catch (error) {
        console.error('Camera capture failed:', error);
      }
    }
  };
  
  if (!device) {
    return (
      <View style={styles.container}>
        <Text>相机不可用</Text>
      </View>
    );
  }
  
  return (
    <View style={styles.container}>
      <Camera
        ref={camera}
        style={StyleSheet.absoluteFill}
        device={device}
        isActive={isActive}
        photo={true}
      />
      
      <View style={styles.overlay}>
        <View style={styles.topBar}>
          <TouchableOpacity 
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Text style={styles.backButtonText}>返回</Text>
          </TouchableOpacity>
        </View>
        
        <View style={styles.bottomBar}>
          <TouchableOpacity 
            style={styles.captureButton}
            onPress={handleCapture}
            disabled={isLoading}
          >
            <View style={styles.captureButtonInner} />
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'black'
  },
  overlay: {
    flex: 1,
    justifyContent: 'space-between'
  },
  topBar: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 50,
    paddingHorizontal: 20
  },
  backButton: {
    backgroundColor: 'rgba(0,0,0,0.5)',
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20
  },
  backButtonText: {
    color: 'white',
    fontSize: 16
  },
  bottomBar: {
    alignItems: 'center',
    paddingBottom: 50
  },
  captureButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: 'white',
    justifyContent: 'center',
    alignItems: 'center'
  },
  captureButtonInner: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#007bff'
  }
});
```

## 4. 构建和部署

### 4.1 浏览器插件构建
```json
// package.json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:chrome": "vite build --mode chrome",
    "build:firefox": "vite build --mode firefox",
    "package": "npm run build && web-ext build"
  }
}
```

### 4.2 Electron应用构建
```json
// electron-builder.json
{
  "appId": "com.englishassistant.desktop",
  "productName": "AI英语工作助手",
  "directories": {
    "output": "dist-electron"
  },
  "files": [
    "dist/**/*",
    "electron/**/*",
    "node_modules/**/*"
  ],
  "mac": {
    "category": "public.app-category.education",
    "target": [
      {
        "target": "dmg",
        "arch": ["x64", "arm64"]
      }
    ]
  },
  "win": {
    "target": [
      {
        "target": "nsis",
        "arch": ["x64", "ia32"]
      }
    ]
  },
  "linux": {
    "target": [
      {
        "target": "AppImage",
        "arch": ["x64"]
      }
    ]
  },
  "nsis": {
    "oneClick": false,
    "allowToChangeInstallationDirectory": true
  }
}
```

### 4.3 自动更新配置
```typescript
// electron/services/autoUpdater.ts
import { autoUpdater } from 'electron-updater';
import { BrowserWindow, dialog } from 'electron';

export class AutoUpdaterService {
  private mainWindow: BrowserWindow;
  
  constructor(mainWindow: BrowserWindow) {
    this.mainWindow = mainWindow;
    this.init();
  }
  
  private init() {
    autoUpdater.checkForUpdatesAndNotify();
    
    autoUpdater.on('update-available', () => {
      dialog.showMessageBox(this.mainWindow, {
        type: 'info',
        title: '更新可用',
        message: '发现新版本，正在下载...',
        buttons: ['确定']
      });
    });
    
    autoUpdater.on('update-downloaded', () => {
      dialog.showMessageBox(this.mainWindow, {
        type: 'info',
        title: '更新就绪',
        message: '更新已下载完成，重启应用以应用更新。',
        buttons: ['立即重启', '稍后']
      }).then((result) => {
        if (result.response === 0) {
          autoUpdater.quitAndInstall();
        }
      });
    });
  }
}
```

---

**文档版本**: v1.0
**最后更新**: 2024年
**维护团队**: 前端开发组