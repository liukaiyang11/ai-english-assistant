# AI英语工作助手 - 技术实现方案

## 技术架构概览

### 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用层    │    │   API网关层     │    │   AI服务层      │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • 浏览器插件    │    │ • 身份认证      │    │ • LightRAG      │
│ • 桌面应用      │◄──►│ • 请求路由      │◄──►│ • 翻译服务      │
│ • 移动端APP     │    │ • 限流控制      │    │ • 语音识别      │
│ • Web管理后台   │    │ • 日志监控      │    │ • OCR识别       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                ▲
                                │
                       ┌─────────────────┐
                       │   数据存储层    │
                       ├─────────────────┤
                       │ • PostgreSQL    │
                       │ • Redis缓存     │
                       │ • 向量数据库    │
                       │ • 文件存储      │
                       └─────────────────┘
```

## 核心技术选型

### 1. 基于现有技术栈的优势

#### LightRAG集成
- **知识图谱构建**: 构建英语学习领域的知识图谱
- **语义检索**: 基于用户查询历史提供相关词汇推荐
- **上下文理解**: 分析词汇在不同语境中的含义

```python
# 基于LightRAG的词汇知识图谱
from lightrag import LightRAG

class EnglishKnowledgeGraph:
    def __init__(self):
        self.rag = LightRAG(
            working_dir="./english_kg",
            llm_model_func=openai_complete_if_cache,
            embedding_func=openai_embedding
        )
    
    def add_vocabulary(self, word, context, translation, source):
        """添加词汇到知识图谱"""
        document = f"""
        词汇: {word}
        翻译: {translation}
        语境: {context}
        来源: {source}
        时间: {datetime.now()}
        """
        self.rag.insert(document)
    
    def get_related_words(self, query):
        """获取相关词汇"""
        return self.rag.query(f"与'{query}'相关的词汇和用法")
```

#### CrewAI多Agent系统
- **翻译Agent**: 专门处理翻译任务
- **学习Agent**: 制定个性化学习计划
- **复习Agent**: 安排和监督复习进度
- **LangGraph编排**: 渐进式引入复杂工作流编排

```python
# CrewAI多Agent协作系统
from crewai import Agent, Task, Crew
from langchain_openai import ChatOpenAI

class EnglishLearningAgents:
    def __init__(self):
        self.llm = ChatOpenAI(temperature=0.1, model="gpt-3.5-turbo")
        
        self.translator_agent = Agent(
            role="专业翻译师",
            goal="提供准确的英语翻译和语境解释",
            backstory="你是一位经验丰富的英语翻译专家，擅长根据语境提供最合适的翻译",
            llm=self.llm
        )
        
        self.learning_agent = Agent(
            role="学习规划师",
            goal="根据用户水平制定个性化学习计划",
            backstory="你是专业的语言学习顾问，能够分析用户水平并制定有效的学习策略",
            llm=self.llm
        )
        
        self.review_agent = Agent(
            role="复习调度器",
            goal="基于遗忘曲线安排最优复习计划",
            backstory="你是记忆科学专家，精通间隔重复算法和个性化复习安排",
            llm=self.llm
        )
    
    def process_translation_request(self, text, context):
        """处理翻译请求"""
        translation_task = Task(
            description=f"翻译并分析文本: {text}，语境: {context}",
            agent=self.translator_agent
        )
        
        learning_task = Task(
            description=f"基于翻译结果，为用户提供学习建议",
            agent=self.learning_agent
        )
        
        crew = Crew(
            agents=[self.translator_agent, self.learning_agent],
            tasks=[translation_task, learning_task],
            verbose=True
        )
        
        return crew.kickoff()
```

### 2. 前端技术实现

#### 浏览器插件 (Chrome Extension)
```javascript
// content.js - 划词翻译功能
class WordSelector {
    constructor() {
        this.isSelecting = false;
        this.selectedText = '';
        this.init();
    }
    
    init() {
        document.addEventListener('mouseup', this.handleSelection.bind(this));
        document.addEventListener('keydown', this.handleKeyboard.bind(this));
    }
    
    async handleSelection(event) {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText.length > 0) {
            const rect = selection.getRangeAt(0).getBoundingClientRect();
            await this.showTranslationPopup(selectedText, rect);
        }
    }
    
    async showTranslationPopup(text, rect) {
        // 调用后端翻译API
        const translation = await this.translateText(text);
        
        // 显示翻译弹窗
        const popup = this.createPopup(translation, rect);
        document.body.appendChild(popup);
    }
    
    async translateText(text) {
        const response = await fetch('https://api.englishassistant.com/translate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${await this.getToken()}`
            },
            body: JSON.stringify({
                text: text,
                context: this.getContext(),
                source: window.location.href
            })
        });
        
        return await response.json();
    }
}

new WordSelector();
```

#### 桌面应用 (Electron)
```javascript
// main.js - Electron主进程
const { app, BrowserWindow, globalShortcut, clipboard } = require('electron');

class DesktopApp {
    constructor() {
        this.mainWindow = null;
        this.init();
    }
    
    init() {
        app.whenReady().then(() => {
            this.createWindow();
            this.registerGlobalShortcuts();
        });
    }
    
    createWindow() {
        this.mainWindow = new BrowserWindow({
            width: 1200,
            height: 800,
            webPreferences: {
                nodeIntegration: true,
                contextIsolation: false
            }
        });
        
        this.mainWindow.loadFile('index.html');
    }
    
    registerGlobalShortcuts() {
        // Ctrl+Shift+T 快速翻译剪贴板内容
        globalShortcut.register('CommandOrControl+Shift+T', () => {
            const clipboardText = clipboard.readText();
            if (clipboardText) {
                this.translateClipboard(clipboardText);
            }
        });
        
        // Ctrl+Shift+S 截图翻译
        globalShortcut.register('CommandOrControl+Shift+S', () => {
            this.captureAndTranslate();
        });
    }
    
    async translateClipboard(text) {
        // 调用翻译服务
        const translation = await this.callTranslationAPI(text);
        
        // 显示翻译结果窗口
        this.showTranslationWindow(translation);
    }
}

new DesktopApp();
```

### 3. 后端服务实现

#### FastAPI后端服务
```python
# main.py - FastAPI应用
from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import HTTPBearer
from pydantic import BaseModel
import asyncio
from typing import List, Optional

app = FastAPI(title="AI英语工作助手API")
security = HTTPBearer()

class TranslationRequest(BaseModel):
    text: str
    context: Optional[str] = None
    source: Optional[str] = None
    user_id: str

class VocabularyItem(BaseModel):
    word: str
    translation: str
    context: str
    source: str
    tags: List[str] = []
    difficulty: int = 1

@app.post("/api/translate")
async def translate_text(request: TranslationRequest, token: str = Depends(security)):
    """翻译文本"""
    try:
        # 调用多个翻译服务
        translations = await get_multiple_translations(request.text)
        
        # AI增强翻译
        enhanced_translation = await enhance_translation_with_ai(
            request.text, 
            request.context,
            translations
        )
        
        # 记录翻译历史
        await save_translation_history(request, enhanced_translation)
        
        return {
            "original": request.text,
            "translation": enhanced_translation,
            "context_analysis": await analyze_context(request.text, request.context),
            "related_words": await get_related_vocabulary(request.text),
            "difficulty_level": await assess_difficulty(request.text)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/vocabulary/save")
async def save_vocabulary(item: VocabularyItem, token: str = Depends(security)):
    """保存词汇到个人词库"""
    user_id = await get_user_from_token(token)
    
    # 保存到数据库
    vocab_id = await db.save_vocabulary(user_id, item)
    
    # 添加到知识图谱
    await knowledge_graph.add_vocabulary(
        item.word, 
        item.context, 
        item.translation, 
        item.source
    )
    
    # 安排复习计划
    await schedule_review(user_id, vocab_id, item.difficulty)
    
    return {"id": vocab_id, "status": "saved"}

@app.get("/api/review/today")
async def get_today_review(token: str = Depends(security)):
    """获取今日复习内容"""
    user_id = await get_user_from_token(token)
    
    # 基于遗忘曲线计算今日复习内容
    review_items = await calculate_review_items(user_id)
    
    return {
        "total_count": len(review_items),
        "items": review_items,
        "estimated_time": len(review_items) * 30  # 秒
    }

async def get_multiple_translations(text: str) -> dict:
    """获取多个翻译源的结果"""
    tasks = [
        translate_with_google(text),
        translate_with_baidu(text),
        translate_with_openai(text)
    ]
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    return {
        "google": results[0] if not isinstance(results[0], Exception) else None,
        "baidu": results[1] if not isinstance(results[1], Exception) else None,
        "openai": results[2] if not isinstance(results[2], Exception) else None
    }

async def enhance_translation_with_ai(text: str, context: str, translations: dict) -> str:
    """AI增强翻译"""
    prompt = f"""
    原文: {text}
    语境: {context}
    
    现有翻译结果:
    Google: {translations.get('google', 'N/A')}
    百度: {translations.get('baidu', 'N/A')}
    OpenAI: {translations.get('openai', 'N/A')}
    
    请基于语境提供最准确的翻译，并解释选择理由。
    """
    
    # 调用LLM进行增强翻译
    enhanced_result = await llm_client.complete(prompt)
    return enhanced_result
```

#### 数据库设计
```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    subscription_type VARCHAR(50) DEFAULT 'free',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 词汇表
CREATE TABLE vocabulary (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    word VARCHAR(255) NOT NULL,
    translation TEXT NOT NULL,
    context TEXT,
    source VARCHAR(500),
    tags TEXT[], -- PostgreSQL数组类型
    difficulty INTEGER DEFAULT 1,
    mastery_level INTEGER DEFAULT 0, -- 掌握程度 0-5
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_reviewed TIMESTAMP,
    review_count INTEGER DEFAULT 0
);

-- 复习计划表
CREATE TABLE review_schedule (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    vocabulary_id UUID REFERENCES vocabulary(id),
    scheduled_date DATE NOT NULL,
    interval_days INTEGER NOT NULL,
    is_completed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 学习统计表
CREATE TABLE learning_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    date DATE NOT NULL,
    words_learned INTEGER DEFAULT 0,
    words_reviewed INTEGER DEFAULT 0,
    translation_count INTEGER DEFAULT 0,
    study_time_minutes INTEGER DEFAULT 0,
    UNIQUE(user_id, date)
);

-- 翻译历史表
CREATE TABLE translation_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    original_text TEXT NOT NULL,
    translated_text TEXT NOT NULL,
    source_url VARCHAR(500),
    context TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 4. AI服务集成

#### 智能复习算法
```python
# review_algorithm.py - 基于遗忘曲线的复习算法
import math
from datetime import datetime, timedelta
from typing import List, Dict

class SpacedRepetitionAlgorithm:
    """间隔重复算法 (基于SuperMemo SM-2)"""
    
    def __init__(self):
        self.initial_interval = 1  # 初始间隔1天
        self.second_interval = 6   # 第二次间隔6天
        self.ease_factor = 2.5     # 初始难度系数
    
    def calculate_next_review(self, 
                            last_review: datetime,
                            interval: int,
                            ease_factor: float,
                            quality: int) -> Dict:
        """
        计算下次复习时间
        quality: 0-5 (0=完全忘记, 5=完美记住)
        """
        if quality < 3:
            # 回答错误，重新开始
            new_interval = 1
            new_ease_factor = ease_factor
        else:
            # 回答正确，增加间隔
            if interval == 1:
                new_interval = 6
            elif interval == 6:
                new_interval = 16
            else:
                new_interval = math.ceil(interval * ease_factor)
            
            # 调整难度系数
            new_ease_factor = ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))
            new_ease_factor = max(1.3, new_ease_factor)  # 最小值1.3
        
        next_review = last_review + timedelta(days=new_interval)
        
        return {
            "next_review_date": next_review,
            "interval_days": new_interval,
            "ease_factor": new_ease_factor
        }
    
    def get_review_items_for_date(self, user_id: str, date: datetime) -> List[Dict]:
        """获取指定日期的复习项目"""
        # 从数据库查询需要复习的词汇
        query = """
        SELECT v.*, rs.scheduled_date, rs.interval_days
        FROM vocabulary v
        JOIN review_schedule rs ON v.id = rs.vocabulary_id
        WHERE v.user_id = %s 
        AND rs.scheduled_date <= %s 
        AND rs.is_completed = FALSE
        ORDER BY rs.scheduled_date ASC
        """
        
        # 这里应该是实际的数据库查询
        return []

class PersonalizedLearning:
    """个性化学习系统"""
    
    def __init__(self, lightrag_client):
        self.rag = lightrag_client
    
    async def analyze_learning_pattern(self, user_id: str) -> Dict:
        """分析用户学习模式"""
        # 获取用户学习历史
        learning_history = await self.get_user_learning_history(user_id)
        
        # 分析强弱项
        weak_areas = self.identify_weak_areas(learning_history)
        strong_areas = self.identify_strong_areas(learning_history)
        
        # 生成个性化建议
        suggestions = await self.generate_learning_suggestions(
            weak_areas, strong_areas
        )
        
        return {
            "weak_areas": weak_areas,
            "strong_areas": strong_areas,
            "suggestions": suggestions,
            "recommended_daily_goal": self.calculate_daily_goal(learning_history)
        }
    
    async def generate_learning_suggestions(self, weak_areas: List, strong_areas: List) -> List[str]:
        """生成学习建议"""
        prompt = f"""
        用户学习分析:
        薄弱领域: {weak_areas}
        强项领域: {strong_areas}
        
        请提供3-5个具体的学习建议，帮助用户改善薄弱环节。
        """
        
        suggestions = await self.rag.query(prompt)
        return suggestions.split('\n')
```

### 5. 部署和运维

#### Docker容器化
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### docker-compose.yml
```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/english_assistant
      - REDIS_URL=redis://redis:6379
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/app/logs
  
  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=english_assistant
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - api

volumes:
  postgres_data:
  redis_data:
```

## 开发时间线

### 第一阶段 (4周) - MVP开发
- Week 1: 后端API基础框架 + 数据库设计
- Week 2: 翻译服务集成 + 用户认证
- Week 3: 浏览器插件开发
- Week 4: 基础复习功能 + 测试

### 第二阶段 (6周) - 完整功能
- Week 5-6: 移动端APP开发
- Week 7-8: AI增强功能集成 (LightRAG + CrewAI)
- Week 9-10: 智能复习算法 + 个性化学习
- Week 10: 多端同步 + 性能优化

### 第三阶段 (4周) - 高级功能
- Week 11-12: 语音功能 + OCR集成
- Week 13: 企业版功能
- Week 14: 部署上线 + 监控

## 技术风险和解决方案

### 1. API限制和成本控制
**风险**: 翻译API调用成本过高
**解决方案**: 
- 实现多翻译源负载均衡
- 缓存常用翻译结果
- 用户限额管理

### 2. 数据同步复杂性
**风险**: 多端数据同步冲突
**解决方案**:
- 实现操作日志和冲突解决机制
- 使用版本控制和时间戳
- 离线模式支持

### 3. AI模型成本
**风险**: LLM调用成本过高
**解决方案**:
- 智能缓存策略
- 批量处理请求
- 本地模型备选方案

---

**文档版本**: v1.0
**技术负责人**: 开发团队
**更新时间**: 2024年